swagger - http://localhost:8080/swagger-ui.html

# MiFiLottery
Проектная практика МИФИ, магистратура

## 1. Общие требования

**Цель:**

Создание системы для проведения лотерейных тиражей с возможностью покупки билетов, определения выигрышей и интеграции с платежными системами.

**Язык программирования** 

* Java 17+. 

**Фрейворк**

* Spring Boot 3.x

**База данных** 

* PostgreSQL 17

**Архитектура** 

* Монолит с четким разделением слоев: Controller → Service → Repository.

**Безопастность**

* Аутентификация через JWT-токены

**Роли пользователей**
  
* USER - покупка билетов, проверка результатов, история своих покупок и результатов тиражей
* ADMIN - управление тиражами, играми, отмена тиражей. Дополнительно должен иметь доступ к статистике и отчётам по всем пользователям.


## 2. Основные компоненты системы

### 2.0. Сущность User ###

**Основные поля**

* id
* role
* telegram
* balance

**Опционально**

* username
* password
* created_at
* is_active
* referal_link

*Примечание: Логин и пароль для аутентификации и выдачи токена лучше, наверное, сделать. Roles можно вынести в отдельную таблицу*

### 2.1. Тиражная служба (Draw Service) ###

Описание: Тиражная служба управляет лотерейными тиражами, их статусами и расписанием. Она отвечает за создание, изменение и отмену тиражей, а также за автоматическое определение результатов.

**Сущности:**

**Draw (Тираж):** 
* id (уникальный идентификатор).
* name (имя или сквозной номер тиража).
* lottery_type_id (тип лотереи, например, "5 из 36").
* start_time (дата и время начала тиража).
* duration (длитеь ность тиража в статусe Active).
* status (статус):
  - PLANNED - тираж создан, но ещё не начался, можно покупать билеты,
  - ACTIVE - тираж активен, можно покупать билеты,
  - COMPLETED - тираж завершен, результаты определены,
  - CANCELLED - тираж отменен.

**DrawResult (Результат тиража):**
* id.
* draw_id (ссылка на тираж).
* winning_combination (выигрышная комбинация чисел или ).
* result_time (время определения результатов).

*Примечание: может сюда положить призового фонда, ведь она фиксируется по результату тиража по сумме проданных билетов, а также добавить JSON поле с массивом/словарем выигравших билетов*

* prize_pool (сумма призового фонда = сумма ьилетов тиража * prize_pool_percentage)
* winning_tickets (например: {"winnners": [{id1:[combination1, prize_amount]}, {id2:[combination2, prize_amount]} ]}, ...])

**LotteryType (Тип лотереи):**
* id.
* description (или name - описание/имя типа лотерии, например, "5 из 36").
* ticket_price (стоимость билета для этого типа лотерии).
* min_ticket(минимальное кол-во билетов для тиража, иначе он не состоится).
* prize_pool_percentage (% от суммы проданных всех билетов, который формирует сумму призового фонда)

*API:*
* POST /api/admin/draws (только ADMIN): Создание тиража с указанием типа лотереи и времени старта.
* GET /api/draws/active: Получение списка активных тиражей.
* GET /api/draws/available: тиражи, в которых можно купить билеты - выборка по статусам ACTIVE + PLANNED).
* PUT /api/admin/draws/{id}/cancel (только ADMIN): Отмена тиража (изменение статуса на CANCELLED).
* GET /api/draws/{id} - детальная информация о тираже.
* GET /api/draws/{id}/results - результаты тиража.

*Логика:*
* Автоматический переход статусов:
* При наступлении startTime статус меняется с PLANNED на ACTIVE.
* По завершении времени тиража статус меняется на COMPLETED, запускается алгоритм определения выигрышей.
* При отмене тиража все связанные билеты помечаются как недействительные.
* Отмена должна быть возможна как для PLANNED, так и для ACTIVE тиражей. Для COMPLETED тиражей отмена недопустима.
* Добавьте возможность просматривать историю завершенных тиражей
* API для получения информации о предыдущих тиражах и их результатах.

### 2.2. Служба генерации билетов (Ticket Service) ###

Описание: Служба генерации билетов отвечает за создание билетов для участия в тиражах. Поддержка двух режимов генерации:
* Предсозданные билеты: Система генерирует билеты автоматически **«на лету»** (для лотерей, где выбор чисел запрещен).
* Пользовательский выбор: Пользователь самостоятельно выбирает числа (например, для лотереи "5 из 36").

**Сущности:**

**Ticket (Билет):**
* id.
* user_id (идентификатор пользователя).
* draw_id (идентификатор тиража).
* Data описание данных билета в JSON: например {"numbers":[1, 5, 10, 15, 20]}
* status (статус: PENDING, WIN, LOSE, CENCELLED). *Примечание: PENDING переименовать в INGAME*

*API:*
* GET /api/tickets/{id} (только USER): Получение информации о билете (числа, статус, тираж).

*Логика:*
* Гененрировать билеты только "на лету" по запросу:
  - не хранить непроданые билеты в БД
  - по запросу генерировать новый случайный билет в соответствии с типом лотерии
  - после оплаты сохранять билет в БД с привязкой к пользователю
  - до оплаты билет имеет только временную привязку в InvoiceData

*Логика автоматической лотереи: генерируем id билета при продаже, а при определении результата выбираем из сгенерированных id случайным образом - только 1 победитель*

* Валидация чисел:
  - Для лотереи "5 из 36": 5 уникальных чисел в диапазоне 1–36.
  - При невалидных данных возвращается ошибка 400 Bad Request.
  - При создании билета проверяется, что тираж в статусе PLANNED или ACTIVE.
* Добавьте возможность пользователям просматривать историю своих билетов и их статусы.
* GET /api/tickets API для получения списка всех билетов пользователя с учетом тиражной информации.

### 2.3. Шлюз оплаты (Payment Service) ###

Описание: Шлюз оплаты отвечает за обработку платежей за покупку билетов с интеграцией с mock-платежной системой.

*Для MVP: 1 invoice = 1 ticket*
*По сути, инфойс - корзина для временного билета*
*Инвойс нельзя удалить - только отменить*

**Сущности:**

**Invoice (инвойс):**
* id.
* user_id - пользователь, создавший инвойс,
* ticket_data данные по билету(JSON из сущности tiket) - для будущего масштабирования нужно сделать массив, чтобы в последствии класть в 1 инвойс несколько билетов.
* register_time – время регистрации.
* payment_link - сгенерированная бэкэндом (платёжным шлюзом) ссылка на оплату
* status:
  - UNPAID - инвойс создан, но не оплачен - по умолчанию
  - PENDING – ожидает оплаты, в этом статусе нельзя отменить
  - PAID - инвойс оплачен
  - REFUNDED - средства возвращены
* cancelled. 0/1 - инвойс отменен, не может быт ьоплачен. Если был оплачен - нужно/можно сделать refund - по-умолчанию - 0.

**Payment (Платеж):**
* id.
* invoice_id - вторичный ключ-ссылка на инвойс
* amount (сумма платежа).
* status (SUCCESS, FAILED).
* payment_time (время выполнения платежа).

*API:*
* POST /api/invoice - зарегестрировать invoice. Параметры: Invoice – инвойс к регистрации, Осуществляет регистрацию инвойса
* POST /api/payments - зарегестрировать платёж (только USER). Параметры: cardNumber (номер карты), cvc (CVC-код). Симулирует успешную (80%) или неудачную (20%) оплату. *Mock-сервис на этом же сервере - принимает запрос на оплату отдаёт результат success/failed*

*Логика:*
* При оплате инвойса делаем проверку в каком статусе тираж (по данным в билете) - если Active - все ок, иначе оплатить нельзя.
* Запрос на оплату (POST /api/payments) "блокирует" инвойс - переводит в статусс PENDING
* Если инвойс в статусе PENDING – его нельзя отменить. Если оплата прошла – он переходит в статус PAID, если оплата не удалась – возвращается в статус UNPAID
* По окончании тиража все неоплаченные инвойсы становятся cancelled.
* Для тестовой среды - для MVP делаем валидацию запроса только по CVC:
  - Любой номер карты принимается, **если CVC = 123**.
  - При успешной оплате билет привязывается к пользователю.
  - При неудаче билет не создается Инвойс возвращается в исходное состояние.

### 2.4. Служба определения результатов (Draw Result Service) ###

Описание: Служба определения результатов отвечает за генерацию выигрышных комбинаций и обновление статусов билетов.

**Логика:**

* После завершения тиража (status = COMPLETED):
* Генерация выигрышной комбинации с использованием SecureRandom.
* Сравнение чисел билетов с выигрышной комбинацией – для билетов типа «5 из 36».
* Определение победителей по правилам лотереи и расчет сумм выигрышей:
  - Для предсозданных билетов: один победитель (полн. совпадение или рандом)
  - Для лотерей с выбором чисел: если в категории несколько победителей, призовой фонд категории делится поровну, или в % соотношении по кол-ву совпавших в билете чисел.
  - Результаты расчета пишем в DrawResults в winning_tickets
*  Обновление статусов билетов (WIN/LOSE).
*  Добавьте возможность пользователям просматривать историю своих билетов и их статусы.

Алгоритмы для разных типов лотерей:

* Лотереи с предсозданными билетами: Проверка полного совпадения чисел.
* Лотереи с выбором пользователя: Проверка частичного совпадения (например, 3 из 5 чисел).

*API:*
* GET /api/draws/{id}/results: Получение выигрышной комбинации тиража.
* GET /api/tickets/{id}/check-result (только USER): Проверка результата билета.
* GET /api/draws/{id}/winners - получение списка победителей тиража.

### 2.5. Служба выгрузки данных (Export Service) ###

Описание:
Формирование отчетов по завершенным тиражам и начисление выигрышей.

**Логика:**
Большинство данных уже будут к этому моменту в DrawResults в winning_tickets
После определения результатов тиража:
* Начисление выигрышей на счета пользователей – внутренний баланс модели USER.
* Выгрузка данных о выигрышных билетах в формате CSV/JSON.
* Отчет должен содержать:
  - Идентификатор тиража.
  - Выигрышную комбинацию.
  - Список выигравших билетов с суммами.
* Добавьте возможность выгрузки статистики по пользователям, выигрышам и тиражам в виде отчетов (например, по месяцам) в формате csv/json

## 3. Нефункциональные требования ##

**Производительность (тестируем через Постман):**
* Время ответа API не более 0.5 секунды.
* Поддержка до 1000 запросов в секунду
  
**Безопасность:**
* Данные платежей (карты) не хранятся в системе.
* JWT-токены с сроком действия 1 час.

**Логирование:**
* Уровни логирования:
  - INFO: Регистрация создания тиражей, успешных платежей.
  - WARN: Попытки доступа к запрещенным ресурсам – ошибки авторизации.
  - ERROR: Сбои при оплате, ошибки генерации результатов.
* Формат логов:
  - JSON-логи для интеграции с системами мониторинга (ELK, Grafana Loki).
  - Обязательные поля: timestamp, service, level, message, user_id (если есть).
* Ротация логов:
  - Настройка ежедневной ротации лог-файлов с архивированием (например, через Logback).

**Масштабируемость:**
* Использование интерфейсов для алгоритмов определения результатов
* Стратегия для разных правил розыгрыша
* Абстрактная фабрика для создания билетов разных типов
* Подготовка к возможному разделению на микросервисы в будущем

## 4. Интерфейсы ##

**REST API:**
* Формат запросов/ответов: JSON.
  
**База данных:**
* Схема должна быть нормализована (2NF).
* Индексы для ускорения поиска по drawId, userId, status.

## 5. Уведомления ##

**Интеграция с мессенджерами или с почтой:**
* Отправка результатов тиражей через Telegram Bot API.
* Email-уведомления: Шаблоны писем для победителей (например, через SendGrid).
* Уведомления администраторов о критических ошибках.

## 6. Тестирование ##

* Интеграционные тесты: коллекция для postman.
  
**Сценарии:**

* Покупка билета с успешной/неудачной оплатой.
* Отмена тиража с проверкой статусов билетов.
* Генерация выигрышной комбинации для разных типов лотерей.
* Вывод всех билетов пользователя

## 7. Дополнительные требования ##

**Деплой:**

* Развертывание в Docker-контейнере.
* Настройка подключения к PostgreSQL через переменные окружения.

**Документация:**

* README с инструкцией по запуску и примеры запросов.

*Примечание: Архитектура должна обеспечивать модульность и легкость поддержки.*

## 8. Дополнительные функции ##

**История операций:**

* Эндпоинт /api/users/me/history для просмотра покупок и выигрышей.

**Возврат средств:**

* API для отмены билета (если тираж отменен).
 
**Реферальная система:**

* Бонусы за приглашение друзей (опционально).

## 9. Алгоритм работы сервиса тиражей ##

**Основная идея**

Сервис тиражей работает на очередях отложенных задач, которые ниже будут называться планировщиками. Основаны они на ScheduledExecutorService.
Один планировщик (executorPlanned) предназначен для запланированных тиражей, статус которых PLANNED. Второй (executorActive) - для активных тиражей, 
статус которых ACTIVE. Если тираж запланирован на какое-то время, то создаётся задача с отложенным временем запуска 
T = startTime - currentTime и передаётся в executorPlanned. Когда эта задача запускается, то она меняет статус тиража из PLANNED на ACTIVE и 
создаёт задачу для executorActive с отложенным запуском T=(startTime+duration)-currentTime.
Когда задача из executorActive запускается, то она меняет статус тиража из ACTIVE на COMPLETED.
Все планировщики содержат в себе тиражи только на текущие сутки, во избежания перегрузки лишними потоками системы.
В начале каждых суток запускается отдельная задача (с помощью  @Scheduled(cron = "0 0 0 * * ?")), которая пробегает по всем тиражам 
и заносит нужные тиражи в соответствующие планировщики.

Работа сервиса тиражей делится на три основные фазы:
* проверка тиражей при запуске
* обработка запроса создания тиража
* актуализация тиражей в начале новых суток

**Проверка тиражей при запуске**
1. При запуске из таблицы Draw вычитываются все тиражи со статусом ACTIVE с датой соответствующей текущей дате и ранее. Список отсортирован от самых старых дат до самых свежих.
2. Если (startTime + duration) <= текущего времени, то тираж помечается как COMPLETED.
3. Если (startTime + duration) > текущего времени, то тираж помещается в executorActive.
4. Далее вычитываются все тиражи со статусом PLANNED с датой соответствующей текущей дате и ранее. Список отсортирован от самых старых дат до самых свежих.
5. Если (startTime + duration) <= текущего времени, тираж просрочен и помечается как CANCELLED.
6. Если (startTime) <= текущего времени, тираж помечается как ACTIVE и отправляется в executorActive.
7. Если (startTime) > текущего времени, тираж отправляется в executorPlanned.
8. Конец.

**Обработка запроса на создание тиража**
1. Если дата запроса тиража в будущем, но не в текущие сутки, то просто помещаем регистрируем тираж в БД как PLANNED.
2. Если тираж в текущие сутки, и сейчас нету подобного тиража с таким же типом лотереи в статусе ACTIVE или PLANNED, то он помещается в executorPlanned и регистрируется в БД.
3. Если тираж с таким же типом лотерии в статусе ACTIVE или PLANNED, то не регистрируем такой тираж и возвращаем ошибку.
4. Конец.

**Актуализация тиражей в начале новых суток**
1. В начале новых суток запускается задача, которая осуществляет проверку, описанную выше в "Проверка тиражей при запуске".
2. Конец


## **Алгоритм работы сервиса генерации билетов**

#### **Основная идея**
Сервис генерации билетов использует паттерн **Стратегия** через `TicketsFactory`, чтобы создавать билеты разных типов в зависимости от правил лотереи.

Генерация билетов происходит **"на лету"** (по запросу) либо из **предсозданного пула** (для `FixedPool`-лотерей). После генерации билет временно резервируется через инвойс ("корзину"). После успешной оплаты инвойса сохраняется в БД.

---

### **1. Типы генераторов билетов**
В системе реализованы три стратегии генерации:

1. **`RandomUniqueTicketGenerator`**
  - Для лотерей, где числа генерируются случайно (например, "5 из 36").
  - Билеты создаются **динамически** при каждом запросе.

2. **`FixedPoolTicketGenerator`**
  - Для лотерей с **предсозданным пулом** билетов (например, "50 билетов по 4 числа").
  - При активации тиража (`ACTIVE`) пул билетов генерируется заранее (`PreGeneratedTicket`).
  - При запросе билета он **забирается из пула**, а не создаётся заново.

3. **`UserSelectedTicketGenerator`**
  - Для лотерей, где пользователь **сам выбирает числа** (например, "6 из 45").
  - Проверяет валидность выбранных чисел перед сохранением.

---

### **2. Процесс генерации билета**

### **2.1. Общий алгоритм**
1. **Получить запрос на генерацию (`POST`)**, в теле запроса должен быть указан  `Draw_id` тиража
1. **Получить тираж (`Draw`)** из БД.
2. **Выбрать генератор** через `TicketsFactory` на основе `AlgorithmRules` лотереи.
3. **Создать билет**:
  - Для `RandomUnique` → сгенерировать случайные числа.
  - Для `FixedPool` → взять билет из пула (`PreGeneratedTicket`).
  - Для `UserSelected` → проверить введённые числа.
4. **Связать билет с пользователем** (если оплачен) или **зарезервировать** через инвойс.

---

### **2.2. Детализация по типам лотерей**

#### **A. Лотереи со случайными числами (`RandomUnique`)**
1. **Запрос**:
   ```http
   POST /api/tickets/new  
   Body: { "drawId": 123 }
   ```  
2. **Генерация**:
  - Через `RandomUniqueTicketGenerator` создаётся драфт билета с набором уникальных чисел в заданном диапазоне.
  - Пример: драфта билета для лотереи "5 из 45".

```java
// Пример JSON в invoice.ticketData:
{
  "drawId": 123,
  "numbers": [5, 12, 23, 36, 41]
}
```

3. **Сохранение**:
  - Если оплата прошла успешно → билет сохраняется в БД.

#### **B. Лотереи с предсозданным пулом (`FixedPool`)**
1. **Инициализация пула**:
  - При переходе тиража в `ACTIVE` вызывается `initPoolForDraw()`.
  - Генерируется N билетов (`poolSize`) и сохраняется в `PreGeneratedTicket`.

2. **Выдача билета**:
  - При запросе билета ищется **первый доступный** в пуле:
    ```java
    Optional<PreGeneratedTicket> ticket = preGeneratedRepo.findFirstByDrawAndIssuedFalse(draw);
    ```  
  - Если пул пуст → генерируется новый билет по тому же алгоритму.

3. **Резервирование**:
  - Билет помечается как `issued = true` и привязывается к инвойсу.

#### **C. Лотереи с выбором чисел (`UserSelected`)**
1. **Запрос**:
   ```http
   POST /api/tickets/new  
   Body: { "drawId": 123, "numbers": [1, 5, 10, 15, 20, 45] }
   ```  
2. **Валидация**:
  - Проверка количества чисел (например, 6 для "6 из 45").
  - Проверка диапазона (1-45).
  - Проверка уникальности.
3. **Создание**:
  - Если числа валидны → билет сохраняется после оплаты.

---

### **3. Интеграция с оплатой (резервирование)** - НЕ РЕАЛИЗОВАНА ИНТЕГРАЦИЯ С ИНВОЙСАМИ
Чтобы избежать **конфликтов** при одновременной покупке:
1. Пользователь запрашивает билет → создаётся **инвойс** (`Invoice`).
2. Билет **не сохраняется в БД**, а хранится в `ticketData` (JSON) инвойса.
3. При оплате:
  - Если успешно → билет сохраняется в `Ticket`.

```java
// Пример JSON в invoice.ticketData:
{
  "drawId": 123,
  "numbers": [1, 5, 10, 15, 20, 45],
}
```

---

### **4. Схема работы**
```mermaid
sequenceDiagram
    User->>+Backend: Запрос билета (POST /tickets/new)
    Backend->>+TicketsFactory: Выбор генератора
    TicketsFactory-->>-Backend: RandomUnique/FixedPool/UserSelected
    alt FixedPool
        Backend->>+PreGeneratedRepo: Найти свободный билет
        PreGeneratedRepo-->>-Backend: PreGeneratedTicket
    else Random/User
        Backend->>+Generator: Создать билет
        Generator-->>-Backend: TicketResponseDto
    end
    Backend->>+InvoiceService: Создать инвойс
    InvoiceService-->>-Backend: Invoice (DRAFT)
    Backend->>-User: 200 OK + invoiceId
```

---

### **5. Особые случаи**
- **Отмена тиража**: Все связанные инвойсы отменяются, билеты **не создаются**.
- **Нехватка билетов в пуле**: Для `FixedPool` → динамическая генерация нового билета.

---

### **Итог**
- **Гибкость**: Поддержка разных типов лотерей через стратегии.
- **Безопасность**: Билеты сохраняются только после оплаты.
- **Масштабируемость**: Легко добавить новые типы генераторов.

