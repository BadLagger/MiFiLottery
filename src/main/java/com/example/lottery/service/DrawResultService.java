package com.example.lottery.service;

import com.example.lottery.dto.DrawStatus;
import com.example.lottery.entity.Draw;
import com.example.lottery.entity.DrawResult;
import com.example.lottery.entity.LotteryType;
import com.example.lottery.entity.Ticket;
import com.example.lottery.repository.DrawRepository;
import com.example.lottery.repository.DrawResultRepository;
import com.example.lottery.repository.TicketRepository;
import com.example.lottery.strategy.LotteryCheckStrategy;
import com.example.lottery.strategy.LotteryCheckStrategyResolver;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class DrawResultService {

    private final DrawRepository drawRepository;
    private final DrawResultRepository drawResultRepository;
    private final TicketRepository ticketRepository;
    private final LotteryCheckStrategyResolver strategyResolver;

    private final ObjectMapper objectMapper = new ObjectMapper();
    private final SecureRandom random = new SecureRandom();

    public DrawResult generateResult(Long drawId) {
        Draw draw = drawRepository.findById(drawId)
                .orElseThrow(() -> new RuntimeException("Draw not found"));

        if (draw.getStatus() != DrawStatus.COMPLETED) {
            throw new RuntimeException("Draw is not completed");
        }

        LotteryType lotteryType = draw.getLotteryType();
        LotteryCheckStrategy strategy = strategyResolver.resolve(lotteryType.getId());

        Set<Integer> winningNumbers = selectWinningNumbers(draw);

        DrawResult result = new DrawResult();
        result.setDraw(draw);
        result.setWinningCombination(
                winningNumbers.stream()
                .sorted()
                .map(String::valueOf)
                .collect(Collectors.joining(",")));
        result.setResultTime(LocalDateTime.now());
        drawResultRepository.save(result);

        List<Ticket> tickets = ticketRepository.findByDraw(draw);
        for (Ticket ticket : tickets) {
            Set<Integer> userNumbers = parseNumbersFromJsonString(ticket.getData());
            boolean win = strategy.isWinning(userNumbers, winningNumbers);
            ticket.setStatus(win ? Ticket.Status.WIN : Ticket.Status.LOSE);
            ticketRepository.save(ticket);
        }

        return result;
    }

    private Set<Integer> selectWinningNumbers(Draw draw) {
        List<Ticket> tickets = ticketRepository.findByDraw(draw);

        if (tickets.isEmpty()) {
            throw new RuntimeException("No tickets found for draw");
        }

        // Выбираем случайный билет как выигрышный
        Ticket randomTicket = tickets.get(random.nextInt(tickets.size()));
        return parseNumbersFromJsonString(randomTicket.getData());
    }

    private Set<Integer> parseNumbersFromJsonString(String jsonString) {
        try {
            List<Integer> list = objectMapper.readValue(jsonString, new TypeReference<List>() {});
            return new HashSet<>(list);
        } catch (Exception e) {
            throw new RuntimeException("Failed to parse numbers from ticket data: " + jsonString, e);
        }
    }

    // Планировщик на случай автогенерации ночью (опционально)
    /*@Scheduled(cron = "0 0 0 * * ?")
    public void autoGenerateDrawResults() {
        List<Draw> draws = drawRepository.findByStatus(DrawStatus.COMPLETED.toString());
        for (Draw draw : draws) {
            boolean alreadyHasResult = drawResultRepository.existsByDraw(draw);
            if (!alreadyHasResult) {
                generateResult(draw.getId());
            }
        }
    }*/

    public Optional<DrawResult> getById(Long id) {
        return drawResultRepository.findById(id);
    }
}